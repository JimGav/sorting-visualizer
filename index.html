<!doctype html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <link rel="stylesheet" href="style.css" />
  <title>Sorting visualizer</title>
</head>

<body>

  <div class="App">
    <header class="header">
      Visualize Sorting Algorithms
    </header>
    <div class="main-container">
      <div className="settings">
        <div style="font-size:15px; display: flex;justify-content: center; gap:10px;align-items: center;">
          <label>SPEED:</label><input id="speed" placeholder='Speed' value="1"></input>
        </div>
      </div>

      <div className='sort-methods'>
        <button id="bubble">Bubble Sort</button>
        <button id="selection">Selection Sort</button>
        <button id="merge">Merge Sort</button>
        <button id="quick">Quick Sort</button>
      </div>

      <div style="border-radius:5px; padding: 5%  5% 0 5% ; margin-top: 5%; border: 1px solid #982c61;">
        <div id='array'></div>
        <button id="regenerate">Regenerate Array</button>
        <div class="results" style="font-size:15px;display: grid; justify-content: center; margin-top: 20px;">
          <div style="display: flex; justify-content: center; align-items:center;gap: 10px;"><label>EXECUTION TIME: </label>
            <p id="execution_time">0</p>
            <p>ms</p>
          </div>
        </div>
      </div>
      <p style="font-size: 18px;">*Execution time may vary due to hardware or implementation. Therefore the
        effectiveness
        of an algorithm should only be determined by its complexity.</br>â†“ </p>
    </div>
    <div class="analysis">
      <ul style="display: grid;justify-content: center; grid-template-columns: 100% 100%;column-gap: 15%;row-gap: 15%;">
        <div class="analysis-block">
          <b style="color:#982c61"> Bubble Sort: </b>
          <p>
            Bubble sort is a straightforward sorting algorithm that repeatedly steps through the list, compares adjacent
            elements, and swaps them if they are in the wrong order. The pass through the list is repeated until the
            list
            is sorted. It's named for the way smaller elements "bubble" to the top of the list with each iteration.
            Though
            simple to understand and implement, bubble sort is inefficient for large lists due to its quadratic time
            complexity, making it impractical for real-world applications. Despite its inefficiency, bubble sort serves
            as
            a fundamental introduction to sorting algorithms and is often used in educational contexts to illustrate
            basic
            sorting concepts.
          </p>
          <button id="bubble-more">MORE</button>
        </div>
        <div class="analysis-block">
          <b style="color:#982c61">Selection Sort:</b>
          <p>
            Selection sort is a simple and intuitive sorting algorithm that iterates through an array, repeatedly
            selecting the smallest element from the unsorted portion and swapping it with the element at the current
            position. This process effectively partitions the array into a sorted section at the beginning and an
            unsorted
            section at the end. With each iteration, the sorted section grows larger while the unsorted section shrinks
            until the entire array is sorted. Despite its simplicity, selection sort's time complexity remains
            quadratic,
            making it less efficient than other sorting algorithms for larger datasets. However, its straightforward
            implementation and intuitive nature make it a valuable educational tool for understanding sorting
            principles.
          </p>
          <button id="selection-more">MORE</button>
        </div>
        <div class="analysis-block">
          <b style="color:#982c61">Merge Sort:</b>
          <p>
            Merge sort is a divide-and-conquer sorting algorithm that divides the input array into smaller subarrays
            until
            each subarray contains only one element. It then merges adjacent subarrays in a sorted order, continuously
            combining them until a single sorted array is formed. The key operation of merge sort is the merging step,
            where two sorted subarrays are merged into a single sorted subarray. This process is repeated recursively
            until the entire array is sorted. Merge sort has a time complexity of O(n log n) in the worst-case scenario,
            making it efficient for sorting large datasets. Additionally, it is stable and can be implemented both
            iteratively and recursively. While merge sort requires additional space for the merging process, its
            predictable performance and stability make it a popular choice for sorting applications.
          </p>
          <button id="merge-more">MORE</button>
        </div>
        <div class="analysis-block">
          <b style="color:#982c61">Quick Sort:</b>
          <p>Quick sort is a highly efficient sorting algorithm based on the divide-and-conquer strategy. It works by
            selecting a 'pivot' element from the array and partitioning the other elements into two subarrays according
            to
            whether they are less than or greater than the pivot. The process is then applied recursively to the
            subarrays. Unlike merge sort, quick sort does not require additional storage for merging, making it
            space-efficient.Quick sort typically has a time complexity of O(n log n) on average, although in the
            worst-case scenario it can degrade to O(n^2). However, it is often faster in practice than other sorting
            algorithms with similar average time complexities due to its efficient partitioning process.</p>
          <button id="quick-more">MORE</button>
        </div>

      </ul>

      <table>
        <tr>
          <th>Algorithm</th>
          <th>Time Complexity (Worst-case)</th>
          <th>Time Complexity (Average-case)</th>
          <th>Time Complexity (Best-case)</th>
        </tr>
        <tr>
          <td>Bubble Sort</td>
          <td>O(n^2)</td>
          <td>O(n^2)</td>
          <td>O(n)</td>
        </tr>
        <tr>
          <td>Selection Sort</td>
          <td>O(n^2)</td>
          <td>O(n^2)</td>
          <td>O(n^2)</td>
        </tr>
        <tr>
          <td>Merge Sort</td>
          <td>O(n log n)</td>
          <td>O(n log n)</td>
          <td>O(n log n)</td>
        </tr>
        <tr>
          <td>Quick Sort</td>
          <td>O(n^2)</td>
          <td>O(n log n)</td>
          <td>O(n log n)</td>
        </tr>
      </table>
    </div>
  </div>
  <div class="Footer">
    <div style="margin: 0;">
      <p>Email: dimitrisgav04@gmail.com</p>
      <p>Feel free to contact me for any questions/suggestions/corrections/feedback</p>
    </div>
    <button id="code-btn">Code Here</button>
  </div>
  </div>

  <script src="main.js"></script>
</body>

</html>